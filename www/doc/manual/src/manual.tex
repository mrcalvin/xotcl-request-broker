
% HEADER
\input{header.tex}
% MAIN 
%body
% embed by-sa metadata file
\ifpdfoutput{
\includexmp{by-sa-2.0}
}{}
%\makeindex
  \begin{document}
  \ifpdfoutput{
  \svnInfo $Id$
  }{}
%titlepage
\title{Request brokerage and remoting for OpenACS}
\author{Stefan Sobernig}
\date{July 2007}
\maketitle
\renewcommand{\contentsname}{}
\tableofcontents 
%body

     \section{Introduction}
        \textbf{xorb}, the X(OTcl) R(equest) B(roker), is an 
infrastructure package for the web development toolkit OpenACS and OpenACS-based frameworks that 
provides for generic means of call abstraction.  Call abstraction, hereby, refers to both distributed and 
non-distributed scenarios. In a non-distributed scenario, xorb is an object-oriented refinement of the well 
established OpenACS facilities also referred to as "service contracts'. In a distributed scenario, xorb 
provides a remoting infrastructure for OpenACS. xorb was designed in a protocol-agnostic manner, i.e. 
our primary intention is to provide support for a variety of remoting protocols. Protocol support is, 
therefore, realised in terms of protocol plug-ins for xorb. So far, we have realised a feature-rich SOAP 
protocol plug-in referred to as \textbf{xosoap}. Both, xorb and its protocol plug-ins are realised in \href{http://media.wu-wien.ac.at/}{XOTcl}, a powerful OO extension to standard Tcl.

This guide, in its current shape, aims at providing the fundamentals of using call abstractions in a 
distributed scenario. We restrict ourselves, for the moment, to the remoting capabilities and therefore 
introduce the reader to the SOAP protocol plug-in, i.e. xotcl-soap (xosoap). The present document and 
resource collection will be steadily extended to cover more general aspects of request brokerage and 
protocol plug-ins available.
\subsection{Sources of information}
Beyond this manual, the following materials are currently available.
\begin{itemize}
\item A \href{http://alice.wu-wien.ac.at:8000/xorb-doc}{wiki} providing for a FAQ section etc.
\item We aim at documenting elements of the public interfaces by means of the OpenACS in-code 
documentation facility and the API Browser. References will be given throughout the manual where 
appropriate. For inline documentation, watch out the OpenACS API Browser for \filelink{xotcl-soap/tcl/xosoap-client-procs.tcl}{xosoap's} and \filelink{xotcl-request-broker/tcl/xorb-stub-procs.tcl}{xorb's interface}.
\item Tutorial prepared for the \href{http://oacs-dotlrn-conf2007.wu-wien.ac.at/}{OpenACS Spring 
Conference 2007} (up-to-date):
\begin{itemize} 
\item \href{http://oacs-dotlrn-conf2007.wu-wien.ac.at/conf2007/file/sobernig-xosoap-slides.pdf?
m=download|Slide set}{Slide set}
\item A \href{http://oacs-dotlrn-conf2007.wu-wien.ac.at/conf2007/file/tutorial-sobernig.mp4?
m=download}{podcast recording} of my talk
\end{itemize}
\item \href{http://nm.wu-wien.ac.at/research/publications/b670.pdf}{Tutorial (slide set)} prepared for the 
OpenACS Fall Conference 2006 (obsolete) 
\end{itemize}
Please, note that these resources reflect and document various stages of development and don't 
necessarily reflect the current state. The only source of information that is kept up-to-date is this manual 
document and its wiki mirror. Moreover, some of them might focus advanced concepts that are properly 
elaborated in the realm of this general-purpose documentation.

Besides, we assume some familiarity with basic XOTcl concepts and its syntax. There is an increasing number of resources available on this nifty language, you might want to check out the following resources to get started:

\begin{itemize}
\item There is a comprehensive \href{http://media.wu-wien.ac.at/doc/tutorial.html}{XOTcl manual} available.
\item A reading tailored to OpenACS developers is to be found in \href{http://www.matuska.org/martin/doc/xotcl-openacs-2007.pdf}{XOTcl for OpenACS Developers}. There is also a \href{http://www.matuska.org/martin/doc/xotcl-openacs-2007-p.pdf}{podcast} on this topic available.
\end{itemize}
\subsection{Copyright terms}
The XOTcl Request Broker (xorb) and all protocol plug-in packages, i.e. currently xosoap, are provided 
under the provisions of the \href{http://creativecommons.org/licenses/LGPL/2.1/}{Lesser General Public 
License (LGPL) version 2.1}. All accompanying and documentary work, including this document, comes 
under the \href{http://creativecommons.org/licenses/by-sa/2.0/at/}{Creative Commons Attributation and 
Share-alike (by-sa) licence}.

     \section{Installation \& configuration guideline}
     	\subsection{Prerequisites}
	\subsubsection{Dependencies}
	\begin{itemize}
	\item \emph{AOLServer} (\textbf{4.0.10/ 4.5}): You can deploy xorb and its plug-ins on both the 4.0.10 and 4.5 family of AOLServer.
	\item \emph{AOLServer} (\textbf{2.6.2+}): We have been developing and running xorb under version 2.6.2, 2.6.4 and, recently, 2.6.5; under both AOLServer versions, respectively.
	\item \emph{XOTcl module} (\textbf{1.5.4+}): We require XOTcl in version \href{http://media.wu-wien.ac.at/download/xotcl-1.5.4.tar.gz}{1.5.4} (or higher) installed.
	\item \emph{xotcl-core} (\textbf{0.70+}): xorb/ xosoap are built upon version 0.70 (or higher).
	 Please, make sure that you comply with the install instructions specified in the \href{http://openacs.org/forums/message-view?message_id=1165990}{OACS developer forum}: In a PostgreSQL environment, there are strict requirements on the completeness and correctness of entries to the acs\_function\_args relation. This will be settled in the near future by patches to the acs-kernel, till then, xotcl-core requires these prior manual backend patch.
	\item \emph{acs-service-contract} (\textbf{5.2.3+}): xorb/ xosoap use the abstraction layer for stored procedures as it comes with recent versions of xotcl-core (::xo:: db::sql::*). This xotcl-core facility (in PostgreSQL environments) requires certain acs\_function\_args entries to be in place. Since versions 5.4.0d1+, PosgreSQL-based stored procedures defined for acs-service-contract  are registered accordingly (acs\_function\_args table) and therefore exposed through the abstraction layer. However, having installed 5.4.0d1+ is not mandatory, as we provide for a generic upgrade and therefore compatibility to lower versions of the package (at least 5.2.3). This upgrade is non-invasive and non-critical to the overall functioning of your OpenACS installation.
	\end{itemize}
	\subsubsection{Patches}
	Provided that you meet the above requirements, no manual patching is needed.
%	\begin{itemize}
%	\item \emph{acs-service-contract}: For versions below 5.4.0d1, we require that you apply the following patch to your PostgreSQL-based backend before proceeding with the actual installation. This means running a SQL script or statements against your data base, for instance, by the following means.
%	\begin{lstlisting}[breaklines=true,frame=single,basicstyle=
%\footnotesize]
%	cd <path-to-your-instance>/packages/xotcl-request-broker/www/doc/patches/0.4
%	psql -U <your-db-user> -f acs-service-contract-function-args.sql
%	\end{lstlisting}
%	After having accomplished the above step, please restart your instance to make sure that the added facilities are available to the actual installation of xorb.
%	\end{itemize}
	\subsection{The XOTcl Request Broker (xorb)}
 	\subsubsection{Installation}
	\begin{enumerate}
	\item Verify the dependencies indicated above. Make sure that XOTcl is available in your AOLServer environment and that the xotcl-core package is in place. As for the latter, you might grab the most recent version from OpenACS's cvs by issueing the call 
	\begin{lstlisting}[breaklines=true,frame=single,basicstyle=\footnotesize]
	cvs -d:pserver:anonymous@cvs.openacs.org:/cvsroot co -r HEAD xotcl-core
	\end{lstlisting}
	\begin{hints}
	\item The actual version of xotcl-core that is strictly required will always be given in the above section on dependencies. Also watch out for mandatory patches indicate above that might apply to the xotcl-core.
	\end{hints}
	\item Make sure that you are running the required or a patched version of acs-service-contract (see above).
	\item Get and install the APM package: You may grab the trunk or tag version directly from svn, by calling either
	\begin{lstlisting}[breaklines=true,frame=single,basicstyle=\footnotesize]
	svn <export | co> http://svn.thinkersfoot.net/xotcl-request-broker/trunk xotcl-request-broker
	\end{lstlisting}
	or
	\begin{lstlisting}[breaklines=true,frame=single,basicstyle=
\footnotesize]
	svn <export | co> http://svn.thinkersfoot.net/xotcl-request-broker/tags/release-<version> \
	xotcl-request-broker
	\end{lstlisting}
	Here, we assume that you are in your packages directory. Alternatively, you might want to \href{http://stefan.thinkersfoot.net/websvn/listing.php?repname=xotcl-request-broker&path=\%2F&sc=0}{browse the current svn repository} to get a tarball (websvn credentials: guest / guest). Besides, APM tarballs are provided at \href{http://media.wu-wien.ac.at/download/}{http://media.wu-wien.ac.at}
	\item Proceed with the common way of installing OpenACS packages. Note, a restart of the server after the APM installation is recommended.
	\item As a first step, you might want to point your browser to \href{/request-broker/admin}{/request-broker/admin} which features a first administrative cockpit for xorb.
	\end{enumerate}
	\subsubsection{Configuration}
	Configuration, primarily, refers to adjusting package parameters. Currently, there are no critical adjustments necessary at this level.   
	\begin{center}
	\begin{footnotesize}
\begin{longtable}{p{0.2\textwidth}p{0.6\textwidth}}
    \toprule
    Option & Description  \\ 
    \midrule
     invocation\_access\_policy & Invocation access policies follow the policy facilities devised by the xotcl-core and the way they are employed by xowiki. In xorb's context, we use them to provide access control to actual servants by means on evaluating (conditional) privileges on service implementations. This feature still needs proper documentation.\\
    chain\_of\_interceptors & xorb allows for injecting specific handlers ("interceptors") that are capable of intercepting and mangling requests and responses (in a chain of interceptors). By default, xorb loads ::xorb::coi as responsible chain of interceptors, you may add your interceptors to this chain or provide your own chain object. \\
    \bottomrule
\end{longtable}
\end{footnotesize}
\end{center}

	\subsection{The SOAP protocol plug-in (xosoap)}
	\subsubsection{Installation}
	\begin{enumerate}
	\item As with the request broker package, grab the APM package: Again, You may take trunk or tag version directly from svn, this time by calling either
	\begin{lstlisting}[breaklines=true,frame=single,basicstyle=
\footnotesize]
	svn <export | co> http://svn.thinkersfoot.net/xosoap/trunk xotcl-soap
	\end{lstlisting}
	or
	\begin{lstlisting}[breaklines=true,frame=single,basicstyle=
\footnotesize]
	svn <export | co> http://svn.thinkersfoot.net/xosoap/tags/release-<version> xotcl-soap
	\end{lstlisting}
	Here, we assume that you are in your packages directory. Alternatively, you might want to \href{http://stefan.thinkersfoot.net/websvn/listing.php?repname=xosoap&path=\%2F&sc=0}{browse the current svn repository} to get a tarball (websvn credentials: guest / guest). Besides, APM tarballs are provided at \href{http://media.wu-wien.ac.at/download/}{http://media.wu-wien.ac.at}
	\item Proceed with the common way of installing OpenACS packages. Note, a restart of the server after the APM installation is recommended.
	\item Go and check out  \href{/xosoap/services/}{/xosoap/services/} where you might find some useful pointers on listening (example) services. 
	\end{enumerate}
	\subsubsection{Configuration}
	In contrast to xorb, xosoap comes with a few configuration options for you. The following table provides an overview and some rough comments where necessary:
\begin{center}
\begin{footnotesize}
  \begin{longtable}{p{0.2\textwidth}p{0.6\textwidth}}
    \toprule
    Option & Description  \\ 
    \midrule
     marshaling\_style & Currently, xotcl-soap provides two marshaling styles that are partly related to the family of WSDL specifications and invocation schemes depicted by this specification. You might choose between RPC/Encoded (::xosoap::RpcEncoded), RPC/Literal (::xosoap::RpcLiteral) or Document/Literal (::xosoap::DocumentLiteral), respectively. Currently, we default to ::xosoap::RpcLiteral. \\
     service\_segment & The parameter value specifies the uri segment that will prefix url endpoints of services, i.e. http://<base\_url>/<package\_key>/<service\_segment</<object\_identifier>. It defaults to "services".\\
     wsi\_bp\_compliant & Compliance of auto-generated interface descriptions to either WSDL 1.1 or \href{http://ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html}{WS-I Basic Profile 1.0/1.1} are not necessarily the same. If you want to make sure that the WSDL generated from your service contracts is strictly complaint to WS-I Basic Profile 1.0/1.1, set this parameter to 1. We currently default to 1. This is still a moving target, what is actually subsumed by the WS-I compat-mode can be followed by in the ChangeLog for the moment and at some point in a more narrative style in this documentation.\\
    \bottomrule
\end{longtable}
\end{footnotesize}
\end{center}
  \section{A quick start guide}\label{sec:quickstart}
  \subsection{xorb}\label{sec:quickstart:xorb}
  \subsection{xosoap}\label{sec:quickstart:xosoap}
  The aim of this quick start section is to provide you with all the critical information required to get you 
started with integrating SOAP in your OpenACS application in terms of consuming an existing SOAP 
service and providing your own as quick as possible. We provide ready-made and take-away code 
snippets and discuss the important steps in further detail. At some point, we might refer to further 
readings or more advanced concepts. 
\begin{hints}
\item By referring to "SOAP" throughout the quick start section, we, more precisely, take into consideration SOAP 1.1 \cite{w3c:2000}. Moreover, we exclusively refer to RPC as messaging or rather (de-)marshaling style. So, any occurrence of "SOAP" should actually be read as "SOAP-RPC 1.1".
\end{hints}
  \subsubsection{How to glue to ...?}\label{sec:xosoap:quickstart:glueto}
  Say, you want to realise a scenario as depicted in Figure \ref{fig:quickstart:xosoap:1}, i.e. you want to 
use the simple echo functionality provided by a remote object or remote procedure through SOAP. In this 
example scenario, we take a remote SOAP service called EchoService as a given. It might realised 
either in xosoap itself or any other SOAP infrastructure framework, such as gSOAP, Apache Axis, .NET 
Remoting and the like. Further, we assume that  EchoService features a call "echoFloat" that requires a 
single argument of type "float" (as defined as "built-in" simple type by the XML schema specification) as 
input and promises to return a value of the very same type. How do you call and consume this little 
example SOAP service by means of xosoap?
\begin{hints}
\item As for data type declarations to be used on OpenACS Service Contracts or remoting protocols, there is a section in this manual dedicated to this issue (see Section \ref{sec:avanced:types}). For the scope of this quick start section, all (data) types refer to what is known as "built-in" primitive types as defined by  XML schema specification 1.0 \cite{w3c:2004}. In xorb, there is a distinction between data types tags you can use in specifying contracts and the type handler behind the scenes. The former, e.g. xsFloat in the below example, are called \emph{type codes}, the actual handler  (an XOTcl object) is an \emph{anything}.
\end{hints}
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.5]{img/consumer.png}
\caption{Our example scenario}
\label{fig:quickstart:xosoap:1}
\end{center}
\end{figure}
\begin{hints}
\item Hold on! If you prefer to skip the little code walk below, just look at the underlying and deployable 
example script xotcl-request-broker/www/doc/manual/examples/xosoap/example-01-soap-consumer.tcl 
or \href{http://openacs-dotlrn.wu-wien.ac.at/request-broker/doc/manual/examples/xosoap/example-01-
soap-consumer.tcl}{direct your browser to it} to see it at work.
\item Interested in more details on a few flavours for realising soap clients: \ref{sec:advanced:interface:what}
\end{hints}
You just need four little steps and a few lines of code to get there:
\begin{enumerate}
\item Provide SOAP-specific configuration information as \emph{glue object}. To be concrete, create an 
instance of the XOTcl class \objlink{::xosoap::SoapGlueObject} and initiate the newly created object with some important bits of information:
%firstline=6,lastline=10
\lstset{breaklines=true,numbers=left,basicstyle=\footnotesize,frame=single}
\lstinputlisting[firstnumber=1,name=example01,linerange={6-10}]{../examples/xosoap/example-01-soap-consumer.tcl}
In these four lines, we create and initiate an instance of the glue object class and provide three 
information bits to it. In line 2, we pass the actual endpoint address. In a conventional setting, the 
transport endpoint corresponds to a valid unique resource identifier (URL) as required by the HTTP 
protocol as transport provider. Line 4 also meets an information requirement at the HTTP level, i.e. the 
value assigned to a specific HTTP header field prescribed by SOAP 1.1 \cite{w3c:2000} (and 1.2) specifications: the 
SOAPAction header field. Line 2 and the setter call on callNamespace, on the contrary, refers to a higher 
protocol level, i.e. the SOAP level. The value of callNamespace will be used to set the namespace 
attached to the method-describing element. This is used by a few SOAP frameworks, e.g. .NET 
Remoting, to dispatch the remote call correctly to the responsible servant. For a detailed list of 
configuration options, please, refer to \objlink{::xosoap::SoapGlueObject}.

Want to learn more ...
 \begin{hints}
\item ... about what 'glue objects' are? See \ref{sec:advanced:xorb:gobjects:what}
% context object > principles of argument parsing
\item ... about re-using 'glue object' to easen your tasks? See \ref{sec:advanced:xorb:gobjects:why}
% concatenation of shadow information
\end{hints}

\item Create a local proxy of the remote object or remote procedure, a so called \emph{client proxy}. This client proxy object holds a proxy method for the remote method or procedure to 
call. There are a few flavours for specifying such a client proxy, the most straight forward, however, is by 
instantiating \objlink{::xorb::stub::ProxyObject} and thus creating a proxy object.
\lstinputlisting[linerange={13-13},name=example01,firstnumber=last]{../examples/xosoap/example-01-soap-consumer.tcl}
The only significant step here is to associate the previously defined glue object to the client proxy. The 
information encapsulated by the glue object is then used by the underlying infrastructure to perform the actual remote call out of the combined information of the glue object and the client proxies interface. So, there it is, what we are still missing is the very client proxy.
\item Specify and realise the interface of your client proxy. The notion of object interfaces, to keep it 
simple, refers to the set methods and their method signatures defined on the object. When looking at 
Figure \ref{fig:quickstart:xosoap:1}, we learn that the interface of the remote object EchoService is quite 
simplistic: There is a single method echoFloat that takes a single argument flagged "inputFloat". The 
argument is, apart from a concrete label, further qualified by a type constraint called xsFloat. These type 
constraints are realised as \href{http://media.wu-wien.ac.at/doc/tutorial.html#non-pos-args}{check 
options on non-positional arguments}, in XOTcl terms. Besides, the interface promises a specific return 
value type, stipulated by passing a type code value as non-positional argument "returns" to ad\_proc.
\lstinputlisting[firstline=16,lastline=21,firstnumber=last]{../examples/xosoap/example-01-soap-consumer.tcl}
The method ad\_proc that comes with \objlink{::xorb::ProxyObject} overloads ad\_proc as defined 
on ::xotcl::Object, see \proclink{::xorb::ProxyObject}{instproc}{ad\_proc} a detailed description.
\item Invoke the proxy method to perform the remote call
\lstinputlisting[firstline=23,lastline=23,firstnumber=last]{../examples/xosoap/example-01-soap-consumer.tcl}
\end{enumerate}
So far, it needed three declarative steps to realise a call to a SOAP service. The public interface of 
xosoap comes with various levels of granularity (see \ref{sec:advanced:interface:what}) with the above 
example referring to the medium-level interface. The higher-level one allows to realise the previous 
example in a total of three steps with only two declarative ones. Let's rewrite the example:

\begin{enumerate}
\item The major difference is that step 1 and 2 of the previous procedure are merged into one single 
step. Note, we now take advantage of a construct that natively comes with xosoap, the 
class \objlink{::xosoap::client::SoapObject}. This makes it completely sufficient, for instance, to import from the Tcl 
namespace ::xosoap::client::* without any need to use facilities of xorb directly (see full code snippet of 
the following example in Listing \ref{lst:quickstart:xosoap:3}.)
\lstset{breaklines=true,numbers=left,basicstyle=\footnotesize,frame=single}
\lstinputlisting[firstnumber=1,firstline=5,lastline=9]
{../examples/xosoap/example-02-soap-consumer.tcl}
\item The second step is, again, devoted to the declaration of the actual proxy interface, a local 
realisation of the echoFloat method on our combined proxy client and glue object:
\lstinputlisting[firstnumber=last,firstline=12,lastline=18]{../examples/xosoap/example-02-soap-consumer.tcl}
\item Finally, once the above is done, you can continue by issuing the call, i.e. invoke on the "remote" 
method:
\lstinputlisting[firstnumber=last,firstline=21,lastline=21]{../examples/xosoap/example-02-soap-consumer.tcl}
\end{enumerate}

 \begin{hints}
\item See the complete example: Listing \ref{lst:quickstart:xosoap:3}. All examples are dumped into the following directory, ready to pick them up: xotcl-soap/www/manual/examples.
\item See (also for more example walk-throughs) Section \ref{sec:advanced:interface:what}
\end{hints}

  
  \subsubsection{Getting glued to ...?}
  In this section, we will briefly look at some straight-forward ways to expose your OpenACS code as a 
SOAP-based service. For this very purpose, we, again, consider the scenario as introduced in the 
previous section, but this time, we shift focus. Now, we want xosoap to realise the EchoService, the 
callee, and not, as previously, the EchoClient, i.e. the caller. Figure \ref{fig:quickstart:xosoap:2} indicates 
that we now aim at realising a service that offers a single remote method, i.e. "echoFloat", that takes a 
single argument of type "float" (again, as prescribed by the XML schema specfication) and is to echo the 
value of the argument back to the caller, again as XML schema built-in "float". The service laterally 
reverses the scenario in the previous section (see Section \ref{sec:xosoap:quickstart:glueto}). How can you 
achieve this?

\begin{enumerate}
\item Declare and deploy an \emph{interface description}. In OpenACS, interface descriptions have a long-standing tradition, however, sometimes neglected. You might be familiar with or, at least, you might have heart of \emph{service contracts} as provided by the OpenACS core. If not, don't panic! For the time being, you just need to know that there is something called "service contract" in OpenACS, that xorb builds upon this core feature of OpenACS and that you now need to create such a service contract, weird enough. Think of an interface description as a fundamental sketch of an object interface that lays down how the interface of a remote object and the interfaces of client proxies mimicking this remote object are to be construed. As for the EchoService in Figure \ref{fig:quickstart:xosoap:2}, a description might look the following way:
\lstset{breaklines=true,numbers=left,basicstyle=\footnotesize,frame=single}
\lstinputlisting[firstnumber=1,firstline=9,lastline=23]{../examples/xosoap/example-07-soap-provider-init.tcl}
The above statement is, in the very literal sense of the word, a descriptive cast of a concrete EchoService service. Apart from a few bits of information targeting you as developer, it outlines that any servant or client proxy is meant to implement a method called "echoFloat", accepting a single argument and, in particular, throwing back a return value of a specific type. Don't forget to "deploy" your newly created service contract by calling:
\lstinputlisting[firstnumber=last,firstline=26,lastline=26]{../examples/xosoap/example-07-soap-provider-init.tcl}
This separate step of deployment might seem an overhead in this simple example, but it renders useful when considering more complex scenarios of designing and lifecycling interface descriptions.
\begin{hints}
\item There is a shrinking violet of an inline documentation available, see in particular, \objlink{::xorb::ServiceContract} and \objlink{::xorb::Abstract}.
\end{hints}
\item Provide servant code and register it with the invocation mechanism. The lines above are, as the notion of "interface description" implies, are mere description of something. What about the realisation of that something, i.e. the actual code block that is executed when the service is called. We refer to this code artefact as servant code or \emph{servant}, in short. But simply creating servant code is not enough, you still have to let xorb know which code block to invoke when calls from client proxies occur. The latter is referred to as providing a "service implementation", i.e. registering your code piece as realisation of a specific service contract! Behind the scenes and in some use cases, it might be more appropriate to deal with these two steps separately, however, in a straight-forward "get-me-a-soap-service" scenario, xorb provides a short cut to accomplish both in a single step:
\lstinputlisting[firstnumber=last,firstline=30,lastline=38]{../examples/xosoap/example-07-soap-provider-init.tcl}
The non-positional argument \emph{-implements} identifies the service contract realised by the underlying servant code, while \emph{-using} allows for specifying the intended delegations, which concrete code block is meant to be called for which abstract call. In our concrete example, we both provide a servant method called echoFloat and, behind the scenes, this servant method is registered as callee for abstract calls on echoFloat as defined by the contract. Note that the facility  \objlink{::xorb::Method} is actually an XOTcl object (i.e. a slot object, to be more precise) that mimics the declaration of instprocs and procs as known from XOTcl. Finally, also deploy your service implementation:
\lstinputlisting[firstnumber=last,firstline=41,lastline=41]{../examples/xosoap/example-07-soap-provider-init.tcl}
At this point, you have accomplished most of the work needed to provide your EchoService. Two things remain to be done:
\begin{hints}
\item Interested in some background reading on OpenACS's service contracts? See the Section \ref{sec:internal:contracts}.
\item See the complete Listing \ref{lst:quickstart:xosoap:7}.
\item Again, you might also want to watch out the API Browser for information on \objlink{::xorb::ServiceImplementation}, \objlink{::xorb::Delegate}, and \objlink{::xorb::Method}.
\end{hints}
\item You might have asked yourself, while going through step 1 and 2, where to actually put your the code outline above. Well, there are several answers to this question, you may choose between the following options:
\begin{itemize}
\item Your package's library files (*-procs.tcl, *-init.tcl): Preferably, drop your code in files situated in the tcl-subdirectory of your package. In either case, whether you choose a *-procs or a *-init file, make sure that you place the following line before the actual code block depicted in step 1 and 2:
\lstinline[breaklines=true]!::xo::db::package require xotcl-request-broker!. Besides, there is a subtle difference between the *-procs and *-init files. The latter are evaluated only once, during server start-up. This means, contracts and implementations are only evaluate once. If you constantly develop, let's say, the servant code declared by your implementation, and you want your modifications/ improvements to take effect without a dedicated server re-start, go for the *-procs option. This way, you can take advantage of xorb's reload and watch support.
\item Your package's W(eb) U(user) I(nterface) files: In principle, you can specify a contract (::xorb::ServiceContract) in one of your www-subdirectory files as well. While it limits their usage, it does not break any functionality. Implementations (::xorb::ServiceImplementation) might as well be specified in WUI files, however, only the most basic variant makes sense in this context. The code of step 2 would not make sense as it defines servant code as well which should be available for all connections, i.e. in the context of all connection threads, and not only the one you specified it in by calling the WUI file.
\item Developer shell: You can also drop the code in the shell as provided by the Developer Support package, however, the limitations for WUI scripts apply here as well.
\end{itemize}

\end{enumerate}
  \begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.5\textwidth]{img/provider.png}
\caption{Our example scenario -- The provider side}
\label{fig:quickstart:xosoap:2}
\end{center}
\end{figure}

Finally, we want to look at two further nifty features for writing the callee interface, i.e. the service implementation, and servants. The first one refers to what is known as \objlink{::xorb::Delegate}, yet another way of linking abstract definitions to concrete servant code blocks. First, the above example could be rewritten in a probably common scenario. Just imagine, you previously created a piece of code (e.g., a proc) and you simply want to expose this artefact as servant instead of creating one by using \objlink{::xorb::Method} as shown above.
Or, you simply articulate the requirement that you keep prospective servant code and mere registration or binding code neatly seperated. In either case, you can revert to the use of little forwarding feature, i.e. \objlink{::xorb::Delegate}. Let's rewrite Listing \ref{lst:quickstart:xosoap:7} accordingly:

The starting point is the assumption that there is an existing code block that we want taking the role of a servant for the abstract echoFloat method defined by our example contract. This particular proc might take the following form:
\lstset{breaklines=true,numbers=left,basicstyle=\footnotesize,frame=single}
\lstinputlisting[firstnumber=1,firstline=6,lastline=10]{../examples/xosoap/example-10-soap-provider-init.tcl}
 
In view of our code base, we could then rewrite our service implementation the following way, using \objlink{::xorb::Delegate}.

\lstinputlisting[firstnumber=last,firstline=39,lastline=47]{../examples/xosoap/example-10-soap-provider-init.tcl}

Let's, for a second, neglect some minor varations we introduced in the above lines and that might distract. Key to the example is that the service implementation now, once the specification has been successfully processed, won't host any callable method on its own, it rather acts as forwarder to your candidate proc. This delegation step is realised by providing an absolute and qualified reference to the target proc to the non-positional argument \lstinline!-for!. Apart from the changed semantics, it will produce the same result as Listing \ref{lst:quickstart:xosoap:7}. Some refinements are also shown in the above snippet that did not show up in the introductory listing.
You might have spotted that \objlink{::xorb::Delegate} takes a couple of extra parameters. The same set is available for \objlink{::xorb::Method}. In fact, both support all parameters known from ad\_proc (or ad\_instproc). In addition, they come with an optional parameter \lstinline!-per-object!. If you are familiar with XOTcl, you will have noticed that methods, and beyond, can be declared directly on objects or for instances of the declaring object. Therefore, the distinction between "proc" and "instproc", just to name the most prominent one. Similarily, you define the \objlink{::xorb::Delegate} and \objlink{::xorb::Method} either at the per-object or per-instance level. Behind the scenes, xorb's invocation mechanism detects either way and will handle dispatches accordingly.
\begin{hints}
\item You might want to check out the API Browser for \objlink{::xorb::Delegate} and \objlink{::xorb::Method}.
\end{hints}
As you just learnt, \objlink{::xorb::Delegate} provides for rather simple delegating dispatch of abstract calls. A thorough look at the above example of a serving proc, i.e. "servantProc", might have created some suspicion: Tcl procs allow for positional argument passing, if we neglect the ad\_proc facility of OpenACS for a second. However, xorb is primarily built around non-positional arguments. We briefly mentioned this fact while describing the semantics of \objlink{::xorb::Abstract}. This is due to the fact that xorb heavily uses \href{http://media.wu-wien.ac.at/doc/tutorial.html#non-pos-args}{XOTcl check options} that are (at least up to the 1.5.x generation) exclusively available to non-positional arguments. Besides, most remoting protocols, including SOAP and XML-RPC adopted this pattern of argument passing \cite{zdun:2005b}. 

Be that as it may, it leaves xorb with servants that do not take non-positional arguments. However, thanks to (XO)Tcl's introspective capabilities, xorb provides for \emph{argument bridging}. It will identify the type of servant code block and adapt the pending call dispatch accordingly, including the rewrite of the passed argument-value list. Note, there are of course limitations to this approach, namely if you consider mixed signatures, containing both positional and non-positional arguments.


  \section{Advanced usage}\label{sec:advanced}
  \subsection{How to test your services}
    \subsection{Public interface}\label{sec:interface}
  \subsubsection{What is the structure of xorb's and xosoap's public interfaces?}\label{sec:advanced:interface:what}
As can be seen from Figure \ref{fig:advanced:interface:1}, the interface available is organised in three 
packages and at the same time levels of granularity. The \emph{lowest-level interface} is deeply 
integrated with XOTcl constructs, especially \xotclref{Object}{::xotcl::Object} and \xotclref{Class}{::xotcl::Class}. xorb, therefore, allows to turn 
any XOTcl object into a client proxy to take advantage of call abstractions (either in a distributed or non-
distributed scenario). At this level, xorb introduces two particular keywords (i.e. methods) that allow to 
define proxy methods in the literal sense of the word on ::xotcl::Object and its sub classes, \proclink{::xotcl::Object}{instproc}{glue}
(or \proclink{::xotcl::Object}{instproc}{ad\_glue}). These methods appear as keywords (one might refer to modifiers, though this is 
not appropriate strictly speaking) to ordinary proc or instproc declarations, however, these method 
declaration don't require or allow method bodies to be defined. The example provided in the quickstart 
guide (see \ref{sec:quickstart:xosoap} can be realised with any XOTcl object, by simply writing:
  \begin{enumerate}
\item First, again, create a "glue" object and pass the necessary call information: 
\lstset{breaklines=true,numbers=left,basicstyle=\footnotesize,frame=single}
\lstinputlisting[firstnumber=1,firstline=6,lastline=10]{../examples/xosoap/example-03-soap-consumer.tcl}
\item In this step, you can simply revert to the use of an ordinary object. Either create one (as shown in the example below) or use existing objects and make them proxy objects by, first, attaching the glue object to it and, second, declare a proxy interface by means of \proclink{::xotcl::Object}{instproc}{ad\_glue} (or \proclink{::xotcl::Object}{instproc}{glue}):
\lstinputlisting[firstnumber=last,firstline=13,lastline=13]{../examples/xosoap/example-03-soap-consumer.tcl}
\lstinputlisting[firstnumber=last,firstline=17,lastline=23]{../examples/xosoap/example-03-soap-consumer.tcl}
\item The actual call is effectuated the same way as in the previous example:
\lstinputlisting[firstnumber=last,firstline=26,lastline=26]{../examples/xosoap/example-03-soap-consumer.tcl}
  \end{enumerate}
At this level, proxy methods appear in their purest forms as mere placeholders for abstract calls 
realising a local representation of a remote (object) interface. Please, note that declarations by means of 
\proclink{::xotcl::Object}{instproc}{glue}/ \proclink{::xotcl::Object}{instproc}{ad\_glue} don't take a method body as they are mere interface descriptors. This makes them 
syntactically comparable to the \xotclref{Object-abstract}{abstract keyword} that comes with XOTcl to 
mimic abstract classes. However, do not align them at the semantic level.
  \begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.75\textwidth]{img/xorb-xosoap-consumer-interface.png}
\caption{Class diagram of interface entities}
\label{fig:advanced:interface:1}
\end{center}
\end{figure}

The \emph{medium-level interface} is already familiar to you when reviewing the quick start 
section. It is provided by xorb and more or less introduces two xorb-specific constructs, 
i.e. \objlink{::xorb::stub::ProxyObject} and \objlink{::xorb::stub::ProxyClass}. While they inherit all capabilities of the low-
level interface, they provide additional facilities to create and use proxy objects. A glimpse at Figure \ref
{fig:advanced:interface:1} reveals that they overwrite the methods \emph{ad\_proc} provided 
by \objlink{::xotcl::Object} and \emph{ad\_instproc} offered by \objlink{::xotcl::Class}. This already suggests that proxy interfaces can 
now be declared in a slightly different manner than by \proclink{::xotcl::Object}{instproc}{glue}/ \proclink{::xotcl::Object}{instproc}{ad\_glue}. While you can still revert to the 
former, \proclink{::xorb::stub::ProxyObject}{instproc}{ad\_proc} and \proclink{::xorb::stub::ProxyClass}{instproc}{ad\_instproc} allow for interface descriptors with method bodies. When looking at 
Listing \ref{lst:quickstart:xosoap:3}, you might notice that the argument declaring the method body is empty (corresponds to an empty Tcl string). For the sake of simplicity, we did not introduce a notable feature of the medium-level interface at this stage that we refer to as \emph{proxy templates}. For a primer on this concept and examples see Section \ref{sec:advanced:template}.

The \emph{high-level interface}, as can been seen from Figure \ref{fig:advanced:interface:1}, is a purely 
protocol plug-in-specific one. As for xosoap, we provide two intregating 
constructs: \objlink{::xosoap::client::SoapObject} and \objlink{::xosoap::client::SoapClass} inherit, expose, and combine 
properties of glue objects and proxy clients in one. This allows for an abbreviated and compact writing of 
SOAP client code, with all facilities introduced by lower interface levels. For an introductory example see 
the quick start section on xosoap (see Section \ref{sec:quickstart:xosoap}) and, in particular, Listing \ref
{lst:quickstart:xosoap:3}.
\subsection{Data type infrastructure}\label{sec:avanced:types}
Providing framework support for data type handling, especially in a cross-language and multi-protocol setup is a challenging task. Nevertheless, framework designers and developers may revert to well documented experiences on these issues and do not have to start from scratch. By these documented experiences, we primarily refer to a set of design patterns, some of them to be found in \cite{zdun:2005b,sommerlad:1998,maetzel:1996}. For the very moment, we do not want to go into details of the framework implementation, rather provide a quick overview on, first, terminology and, second, facilities to be used by you, the developer.

As for terminology, there are just very few concepts to remember. If you recall the examples in specifying client proxies or service contracts (see Section \ref{sec:quickstart:xosoap}), the way you specified the signature of a proxy method or \objlink{::xorb::Abstract} always involved specific \href{http://media.wu-wien.ac.at/doc/tutorial.html#non-pos-args}{check options}. These might look familar: 

 \lstinputlisting[numbers=none,firstline=17,lastline=17]{../examples/xosoap/example-01-soap-consumer.tcl}

     \lstinputlisting[numbers=none,firstline=10,lastline=13]{../examples/xosoap/example-07-soap-provider-init.tcl}

\href{http://media.wu-wien.ac.at/doc/tutorial.html#non-pos-args}{Check options}, again, are a native XOTcl concept to formulate constraints of various types on non-positional arguments. In xorb, however, we use this native XOTcl mechanism to specify special, i.e. protocol-specific type constraints. "xsFloat", as used and shown in the above examples, is referred to as \emph{type code}, i.e. a short-cut identifier for a specific type handler. The actual type handler, i.e. \objlink{::xosoap::xsd::Float} is named \emph{anything type}, or simply \emph{anything}. The main idea of anythings are nicely elaborated on by \cite{sommerlad:1998,maetzel:1996}, however, the main idea is to provide a generic and uniform value container that comes with on-demand casting. 
\begin{hints}
\item Note, some clarifying side notes might be required at this point: The term casting may not be mistaken for what it refers to in compiled and (strongly) typed languages. In the realm of xorb, it simply refers to exposing a value in accordance with some value space and representation constraints.
\item Another side note might be appropriate. The term "type code" is prominently used in another, pure-SOAP framework written in and for Python, i.e. the Zolera SOAP infrastructure (ZSI, \cite{zsi:2007}). However, type codes though realising a comparable aim, are properties to Python objects later used by type-specific (de-)marshalers. In xorb, type code serve a more declarative purpose, simply by hijacking the \href{http://media.wu-wien.ac.at/doc/tutorial.html#non-pos-args}{check option mechanism} of XOTcl.
\end{hints}
The third and last concept realises what is need to provide for multi-protocol support. Just imagine, you want to re-use, or rather, expose a service contract originally defined for the local use in an OpenACS instance as interface description for a SOAP-based service. Type codes such as string, integer, etc. need to be resolved for the scope of SOAP and WSDL handling. Therefore, xorb comes with the idea of \emph{type sponsorships}. A \emph{type sponsor} is a data type handler, i.e. an anything, that comes with a protocol plug-in and announces, upon initialisation, itself as sponsor to a xorb general-purpose anything. The xorb-specific anything then, upon being processed during the handling of invocation dispatches, resolves its sponsor for the actually used protocol. 

Find below a list of currently supported types, providing the type codes at hand and the anythings acting in the background. Rows read as sponsorship relationships (if realised).

\begin{center}
\begin{footnotesize}
  \begin{longtable}{p{0.3\textwidth}p{0.3\textwidth}p{0.3\textwidth}}
    \toprule
    xorb types \begin{tiny}(type code / anything)\end{tiny} & xosoap types \begin{tiny}(type code / anything)\end{tiny} & comments \\ 
    \midrule
    void |~\objlink{::xorb::datatypes::Void} & xsVoid |~\objlink{::xosoap::xsd::XsVoid} & Void is a particular type	descriptor (not featured in XML schema or the like), more or less, making explicit when block calls do not convey results in explicit invocation. This might not be unambiguously expressible by language means, as in Tcl, and is a particular challenge in cross-language settings. \\
    \midrule
    string | \objlink{::xorb::datatypes::String}  & xsString | \objlink{::xosoap::xsd::XsString}  & See \xsd{string} \\ 
    \midrule
    integer | \objlink{::xorb::datatypes::Integer} & xsInt | \objlink{::xosoap::xsd::XsInt}  & See \xsd{int}. Note, XOTcl actually comes with a native "integer" check option, this is, however, overdefined in the realm of xorb. The sponsorship of xsd:int for a Tcl integer is not yet quite decided, but it has been proven useful in known scenarios.\\ 
    \midrule
boolean |~\objlink{::xorb::datatypes::Boolean} &  xsBoolean |~\objlink{::xosoap::xsd::XsBoolean}  & See \xsd{boolean}\\
\midrule
timestamp |~\objlink{::xorb::datatypes::Timestamp} &  n/a  & We assumed, at the xorb side, a correspondence to the SQL:1999  data type "timestamp" WITHOUT timezone\\
\midrule
uri |~\objlink{::xorb::datatypes::Uri} &  n/a & We provide for some RFC 3986 validation.\\
\midrule
version |~\objlink{::xorb::datatypes::Version} &  n/a & Uses regular expression taken from OpenACS package manager.\\
\midrule
float |~\objlink{::xorb::datatypes::Float} &   xsFloat |~\objlink{::xosoap::xsd::XsFloat} & See \xsd{bytearray}\\
bytearray |~\objlink{::xorb::datatypes::Bytearray} & n/a & At the xorb-side, it is not clear to us what is actually labelled "bytearray" and which particular forms of Tcl strings are meant to be ruled by this type description.\\
\midrule
object |~\objlink{::xorb::datatypes::Object} & soapStruct |~\objlink{::xosoap::xsd::soapStruct}  & This sponsor relationship might change in the near future, as soon as the marshaling styles in xosoap are consolidated. The use of ::xotcl::Objects in xorb is not quite clarified, but shown here for the sake of completeness.\\
\midrule
n/a & xsDecimal |~\objlink{::xosoap::xsd::XsDecimal} & See \xsd{decimal} \\
\midrule
n/a & xsInteger |~\objlink{::xosoap::xsd::XsInteger} & See \xsd{integer} \\
\midrule
n/a & xsLong |~\objlink{::xosoap::xsd::XsLong} & See \xsd{long} \\
\midrule
n/a & xsDouble |~\objlink{::xosoap::xsd::XsDouble} & See \xsd{double} \\
\midrule
n/a & xsDate |~\objlink{::xosoap::xsd::XsDate} & See \xsd{date} \\
\midrule
n/a & xsTime |~\objlink{::xosoap::xsd::XsTime} & See \xsd{time} \\
\midrule
n/a & xsDateTime |~\objlink{::xosoap::xsd::XsDateTime} & See \xsd{dateTime} \\
\midrule
n/a & xsBase64Binary |~\objlink{::xosoap::xsd::XsBase64Binary} & See \xsd{base64Binary} \\
\midrule
n/a & xsHexBinary |~\objlink{::xosoap::xsd::XsHexBinary} & See \xsd{hexBinary} \\
\midrule
n/a & soapArray |~\objlink{::xosoap::xsd::SoapArray} & Depending on the message/marshaling
style we either go for the SOAP encoded array or the WS-I compliant array notation. \\
    \bottomrule
\end{longtable}
\end{footnotesize}
\end{center}

 \subsection{Proxy templates}\label{sec:advanced:template}
Proxy templates or rather template methods on proxy objects follow a primary intention: Extending the 
use of pure interface descriptors to full-featured methods that allow to pack program logic along with a 
call abstraction in a single method body. Our intention can be best summarised when following the idea 
of the Template Method pattern as documented by \cite{gof:1994}. As the term "template" suggests, there 
might be scenarios that integrate call abstraction, or in our remoting scenario simply remote calls, in 
more complex (i.e. multi-step) behaviour. This is, certainly, also realisable with the lower-level interface. 
However, it would require another construct, either a proc, or a sub class etc., that combines the general 
behaviour and the invocation references to the abstract calls. By means of proxy template methods as 
introduced by the medium-level interface you can know write template code and invocations of 
abstract calls in the same method block, making encapsulation in this respect more seamless. A 
primary, and still easily graspable example are conditional invocations of abstract calls. Let's take the 
following example of Listing \ref{lst:quickstart:xosoap:2} where we simply rewrite lines 16 -- 21. This 
yields the following (see Listing \ref{lst:quickstart:xosoap:5} for the complete example): 
\lstset{breaklines=true,numbers=left,basicstyle=\footnotesize,frame=single}
\lstinputlisting[firstnumber=1,firstline=16,lastline=28]{../examples/xosoap/example-04-soap-consumer.tcl}
We draw your attention to the last argument of the \proclink{::xorb::stub::ProxyObject}{instproc}{ad\_proc} call which perfectly resembles the declaration of a method body. The exemplary condition we introduce here is only to simplistic but 
delivers the message. You might have noticed that the floating point number used in the EchoClient/
EchoService example corresponds to the decimal representation of the golden ratio phi. We, now, in our 
proxy template method, introduce a constraint which limits the value space accepted to all decimals that 
round to the same integer as the most accurate decimal expansion of the golden ratio, given by the 
formula \begin{math} (1 + \sqrt{5}) / 2\end{math}. If, and only if this value validation is passed, we want 
the abstract call to be invoked. At this point, you might have realised that the \href{http://media.wu-wien.ac.at/doc/tutorial.html#class_method_chaining}{::xotcl::next} command is the 
forwarder to the actual proxy method. 

Now, once you got the main idea behind this example, take a closer look  at the declaration of 
arguments in line 17. You might notice that there is a slight but important modification of how the 
argument inputFloat is specified. In fact, we added an additional \href{http://media.wu-wien.ac.at/doc/tutorial.html#non-pos-args}{check option} "glue" which is 
mandatory as soon as you provide a non-empty method body to either \proclink{::xorb::stub::ProxyObject}{instproc}{ad\_proc} and \proclink{::xorb::stub::ProxyClass}{instproc}{ad\_instproc}. There 
are two reasons for this requirement: First, regarding concepts and clarity for you as developer, you are 
now specifying two method records (i.e. set of arguments plus check options)  within one single step. On 
the one hand, the record for the decorating method (the proxy template method) called "echoFloat" and, 
on the other hand, the actual proxy method "echoFloat". We, therefore, distinguish between an inner and 
and outer record. Both records might be identical but not necessarily. Second, regarding internals, it is 
required to explicitly distinguish between elements of either record. Lets have a look at another variation 
of the previous example (see Listing \ref{lst:quickstart:xosoap:6}):
%
\lstinputlisting[breaklines=true,numbers=left,frame=single,basicstyle=
\footnotesize,firstnumber=1,firstline=16,lastline=34]{../examples/xosoap/example-05-soap-consumer.tcl}
%
Referring to lines 3, we extended the method's record by an additional \href{http://media.wu-wien.ac.at/doc/tutorial.html#non-pos-args}{non-positional argument} and 
two positional ones. In fact, "annotating" a non-positional argument with "glue" assigns it to be member in the proxy record, while all the others, especially the other non-positional arguments, won't be 
interpreted as elements of the proxy interface. At the same time, you will be able to use equally named 
variables containing the arguments" values in the scope of the proxy template method. The final call to 
the proxy object by means of the template method might take the following form:
%
\lstinputlisting[breaklines=true,numbers=left,frame=single,basicstyle=
\footnotesize,firstnumber=last,firstline=37,lastline=41]{../examples/xosoap/example-05-soap-consumer.tcl}
%
Apart from the constraint scenario, template methods also proof useful when you (for whatever reason) 
want to deviate from the proxy interface (i.e. the inner record). This might true in the following cases:
\begin{itemize}
\item In case you need to mangle the argument values before being passed to the remote method, or
\item if you do not expose all arguments stipulated by the proxy interface (i.e. the inner record) in the 
outer record.
\end{itemize}
%
In the following variation of an initial listing (see Listing \ref{lst:quickstart:xosoap:5}), we give provide an 
example for the first case. Let" see:
%
\lstinputlisting[breaklines=true,numbers=left,frame=single,basicstyle=
\footnotesize,firstline=29,lastline=33]{../examples/xosoap/example-06-soap-consumer.tcl}
%
Here, we simply take the inbound value for inputFloat and increase it by 1. This updated value should 
then be passed to the remote method to be communicated to the call point. Two important aspects 
should be retained from this snippet: First, if you do so, you have to explicitly append argument-value 
pairs to \href{http://media.wu-wien.ac.at/doc/tutorial.html#class_method_chaining}{::xotcl::next}. Otherwise, \href{http://media.wu-wien.ac.at/doc/tutorial.html#class_method_chaining}{::xotcl::next}, if called without any appended terms, passes on the last 
argument list on the call stack. Second, if you decide to do so, you have to provide all arguments 
to \href{http://media.wu-wien.ac.at/doc/tutorial.html#class_method_chaining}{::xotcl::next} that are required by the method shadowed by \href{http://media.wu-wien.ac.at/doc/tutorial.html#class_method_chaining}{::xotcl::next}. Required arguments are both 
non-positional arguments flagged "glue" or "required" and positional arguments with no default values in 
the record declaration.
%
\begin{hints}
\item We assume that your are familiar with the basic mechanism of inheritance XOTcl delivers to you. If 
you are new to XOTcl or its conceptual "sponsors" such as CLOS etc., you might want to consider 
studying the relevant sections.
\item You might want to give it a try. Just edit the last line of the example outlined above and change the 
value passed as "inputFloat" so that it once validates correctly and once fails.
\end{hints}
%
Using \href{http://media.wu-wien.ac.at/doc/tutorial.html#class_method_chaining}{::xotcl::next} in this setting is both a slight redefinition of its semantics in view of XOTcl inheritance, 
and a pointer to the internal implementation of our proxy templates or proxy template methods: The 
declarative information passed to ad\_proc or ad\_instproc is used both (a) to specify a proxy method 
and register it with invocation infrastructure and (b) to create a decorator to the actual proxy object in 
terms of a XOTcl mixin class. This decorator hosts the method body as declared with \href{http://media.wu-wien.ac.at/doc/tutorial.html#class_method_chaining}{::xotcl::next} 
resolving to the shadowed proxy method.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.5\textwidth]{img/proxy-template.png}
\caption{Call indirection as used for proxy templates}
\label{fig:advanced:templates:1}
\end{center}
\end{figure}

Figure \ref{fig:advanced:templates:1} aims at sketching the internals of proxy template methods and the 
behaviour shown above. Again, we assume some familiarity with XOTcl concepts, especially mixins as 
XOTcl's realisation of abstract sub classes. The main messages from Figure \ref{fig:advanced:templates:1} are the following:
\begin{itemize}
\item Calls upon objects that mixin classes are registered with are indirected according to a certain order 
of precedence, visualised by the call path in Figure  \ref{fig:advanced:templates:1}.
\item What previously has been referred to as outer interface is the method record of echoFloat defined 
on the mixin class (i.e. \lstinline!::EchoClient::__indirector__!). The inner record refers to the record 
declaration of echoFloat of EchoClient.
\item The original or native call path in XOTcl would continue along the inheritance and realisation 
(instantiation) path, involving e.g. \objlink{::xorb::stub::ProxyObject} and Object in Figure  \ref{fig:advanced:templates:1}. 
However, in the context of proxy templates, the call as such leads to the actual invocation of the 
abstract call.
\end{itemize}
\begin{hints}
\item The subtle difference between inner (proxy) record and outer (template) record should be kept as important message from the previous section. It provides a powerful mechanism to the developer, however, might be a confusing way of mixing-up signatures at first glance.
\end{hints}
  \subsection{Glue objects}\label{sec:advanced:xorb:gobjects}
  \subsubsection{What is the idea of glue objects?}\label{sec:advanced:xorb:gobjects:what}
  Glue objects, as represented by all sub-classes of \objlink{::xorb::stub::ContextObject}, are the xorb-specific flavour of what is more commonly known as \emph{context objects} in language design. Context objects, in short, represent a specific pattern of argument passing applicable to various object-based language environments \cite{zdun:2005b}. The technique comprises the use of a generic or specifically typed object as single argument to operations with the actual arguments being stored as per-object variables (or more commonly, instance variables). The use of context objects has been suggested for a set of scenarios. These might be reflected against the requirements and design decisions taken in xorb's proxy interface (see Section \ref{sec:interface}).
  
First, it allows to avoid the escalation of operation signatures which is a common risk when a considerable amount of arguments needs to be passed. This is certainly given in the scope of xorb and its protocol plug-ins, just to take \objlink{::xosoap::client::SoapGlueObject} as an example. The list of properties is, by the way, not taxonomic but rather open for further extensions provided that this required due to a couple of reasons. The most prominent one is \emph{concatenation} of protocol-specific shadow information, e.g. whenever a new transport handler (SMTP, JMS) is added it might require new properties at the level of the most specific glue object. Another source of an increased need of top-down configurability is the considerable level of heterogeneity between remoting frameworks interacting. This heterogeneity ranges from variation in (de-)marshaling styles, resolution mechanisms to fundamental modes of interaction.

Second, the quality of arguments, i.e. their varying structure, might be another source of complexity that can be better abstracted from by means of context objects. This is somehow closely related to aspect five outlined below.

Third, the set of arguments to be passed might vary from invocation to invocation, a requirement that is rather hard to serve by more conventional argument passing techniques in an elegant and effective manner. The actual argument being an object or even a typed object, we might revert to the given mechanisms of inheritance and polymorphism to model these variations more appropriately.

Fourth, escalated operations signatures are hard to maintain in generic framework designs, where an arbitrary number and arbitrary kinds of clients manipulate these bits of information. This is valid for the generic extension mechanisms that come with xorb, for instance the interceptor infrastructure.

Fifth, context objects allow to specify an interface or even a protocol for manipulating the stored argument data. By interface, we refer to a set of accessors, for instance, a protocol, however, would require more sophisticated features. Though this can be realised in various language settings, we now concentrate on XOTcl. XOTcl comes with a specific kind of objects, so called \href{http://media.wu-wien.ac.at/doc/tutorial.html#slots}{slots}, that generalise the idea of object properties or parameters (as known from other environments) and introduce manager objects for object-level variables. Slots allow various fine-granular interceptions to be executed upon manipulation of object states. This allows to enforce protocols in terms of canonical naming, validation of value spaces etc. in a neat object-centric manner.

Context objects in the scope of remoting frameworks, in their role as \emph{invocation contexts}, are thoroughly discussed and exemplified in \cite{zdun:2005}. A more general sketch in the same direction but applicable to a wider range of domains can be found in \cite{kelly:2003}.

Context objects are also applied as solution to another design problem in xorb, namely the provision of a generic infrastructure for data type handling across boundaries of protocol plug-ins (see Section \ref{sec:avanced:types}). This relates mainly to another flavour of the concept of context objects elaborated on both by \cite{maetzel:1996,sommerlad:1998}. 
  
  \subsubsection{How to use scoping on glue objects for re-use?}\label{sec:advanced:xorb:gobjects:why}
  Against the basic notion of context objects (see Section \ref{sec:advanced:xorb:gobjects:what}), \emph{glue objects}, the xorb-specific flavour of context objects, have already been introduced in at least two notational forms in the quick start guide (see \ref{sec:quickstart:xosoap}) to the reader. There is, however, an advanced usage that can be applied to glue objects that we refer to as \emph{scoping}. Behind the scenes, this feature is the result of a specific order of precedence when resolving the glue object that, in turn, is used for further processing of a call issued upon a client proxy. There are two dimensions of precedence, one regarding the \emph{moment of resolution} (declaration or call time) and the \emph{scope of reach} of a glue object (see Figure \ref{fig:advanced:scoping:2}).
  \begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.45\textwidth]{img/scoping-glue-objects-structure.png}
\caption{Precedence order for resolving glue objects}
\label{fig:advanced:scoping:1}
\end{center}
\end{figure}
As shown in Figure \ref{fig:advanced:scoping:1}, upon issue of a call upon a client proxy (EchoClient), the \objlink{::xorb::stub::Requestor} follows a three-level precedence:
\begin{enumerate}
\item The glue object reference passed to the non-positional argument "glueobject" on either \proclink{::xotcl::Object}{instproc}{glue}, \proclink{::xotcl::Object}{instproc}{ad\_glue}, \proclink{::xorb::stub::ProxyObject}{instproc}{ad\_proc} and \proclink{::xorb::ProxyClass}{instproc}{ad\_instproc} take the highest precedence. This order of precedence is enforced upon declaration time, i.e. the reference is compiled into the body of the proxy method. This level of specifying a glue object allows to realise client proxies as mere collections of remote procedure proxies (and not proxies in the OO sense).
\item As can be learnt from Figure \ref{fig:advanced:scoping:1} and introduced in Listing \ref{lst:quickstart:xosoap:3}, the role of client proxy and glue object are unified in a set of objects, namely \objlink{::xosoap::client::SoapObject} or  \objlink{::xosoap::client::SoapClass}. If the requestor identifies a proxy object of this kind, it will be granted second highest precedence. We refer to this level as the per-object scope (see Figure \ref{fig:advanced:scoping:2}). As for the scope, it is applicable to all proxy methods defined on the client proxy.
\item In Listing \ref{lst:quickstart:xosoap:1} we can find that there is also a property "glueobject" available for all objects of type ::xotcl::Object. This property, or rather the glue object assigned to it, takes the lowest precedence in the resolution order. Comparable to level 2, it applies to all proxy methods defined, however, as the glue object is a distinct entity from the client proxy, it is potentially re-usable for various client proxies. Therefore, we refer to the level of precedence as the shared scope (see Figure \ref{fig:advanced:scoping:2}).
\end{enumerate}
  \begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.45\textwidth]{img/scoping-glue-objects-scheme.png}
\caption{Dimensions of precedence: resolution time \& scope of reach.}
\label{fig:advanced:scoping:2}
\end{center}
\end{figure}
A comparison of these three configurations yields some insights on (dis-)advantages and provides some  hands-on usage examples. Using both the per-method and per-object/ shared scope within a single proxy object allows to implement more than just one interface through a single proxy object. However, this decision needs to be taken upon declaration time as this is a limitation of the current per-method scoping. Also, we so provide the means to specify both proxies for remote methods (in the strict OO sense) and remote procedures in a single entity. Let's look at a slight modification of Listing \ref{lst:quickstart:xosoap:3} that aims at illustrating this first configuration. In a first step, we add a second glue object which contains a different set of configurations options, in particular it targets a different endpoint:
%
\lstset{breaklines=true,numbers=left,basicstyle=\footnotesize,frame=single}
\lstinputlisting[firstnumber=1,firstline=6,lastline=8]{../examples/xosoap/example-08-soap-consumer.tcl}
%
Note, EchoClient as declared in Listing \ref{lst:quickstart:xosoap:3} already contains shadow information of a glue object. If we now pass the second glue object defined to the ad\_proc declaration, this second glue object takes precedence over the first one, i.e. EchoClient itself.
%
\lstinputlisting[firstnumber=last,firstline=18,lastline=24]{../examples/xosoap/example-08-soap-consumer.tcl}
%
The ultimate result of this minor tweak in Listing \ref{lst:quickstart:xosoap:8} is that the call will be delivered to a remote object that listens at a different endpoint than the one in Listing \ref{lst:quickstart:xosoap:3}.\\\\
Both, per-object and shared scope, allow for more simplified notations of proxy objects.  As for re-use, the per-object scope is primarily centred around the re-use of the proxy interface as represented by the proxy object while continuously, over the program flow, adapting the configuration in terms of glue object manipulations. The shared scope puts emphasis on the re-use of a given glue object on multiple proxy objects. Moreover, it allows for dynamic, non-hierarchical refinements through \href{http://media.wu-wien.ac.at/doc/tutorial.html#mixins}{mixins}. In doing so, we gain the opportunity can inject glue objects for a selected period of time upon certain conditions into client proxies. 

Again, to provide a hands-on experience, let's have a look at Listing \ref{lst:quickstart:xosoap:9}. In fact, we try to achieve the same behaviour as realised in Listing \ref{lst:quickstart:xosoap:8} but by completely different means. This time we want to decorate our previously defined client proxy at an arbitrary moment during run time. For this purpose, we need an appropriate decorator, such as:
%
\lstinputlisting[firstnumber=last,firstline=27,lastline=33]{../examples/xosoap/example-09-soap-consumer.tcl}
%
The decorator, an XOTcl mixin class, can be realised in manifold ways, the above is only one of a couple of options at hand. The main idea, however, is that a new glue object (ProxyDecorator::GlueObject) is return upon calls to the decorator's "glueobject" method. The actual step of decorating the client proxy might take the following form:
%
\lstinputlisting[firstnumber=last,firstline=37,lastline=37]{../examples/xosoap/example-09-soap-consumer.tcl}
%
Once this is achieved, calls to the accessor "glueobject" of the equally named attribute won't deliver the original glue object, but the decorator's one. This is due to the basic mixin mechanism provided by XOTcl with the decorator's "glueobject" method shadowing the actual accessor called "glueobject". 
After the successful decoration, the call, again, is delivered to the endpoint stipulated in the second glue object.

We want to remind the reader at this point that the above classification somehow need to be considered oversimplifying. The main reason is the distinctions and elaborations are based on constructs that were defined, as an explicit design decision, as public interface (see Section \ref{sec:interface}). However,  as many features are built upon generic XOTcl mechanisms, the same statements and considerations are equally valid for other entities or interface levels: Any object of type \objlink{::xotcl::Object} may be associated with a glue object and can hold proxy methods through \proclink{::xotcl::Object}{instproc}{glue}/\proclink{::xotcl::Object}{instproc}{ad\_glue}, each of them being able to reference a distinct glue object. Therefore, the account given above applies to more than the scenarios outlined in the scope of this introductory section.

Besides, the current implementation comes with a couple of minor that might not be obvious to the developer. In particular, we do not distinguish between per-object or per-instance scopes. That is, a glue object specified on a class object will be valid for both its instances' and its own scope.
  \section{Internals}\label{sec:internal}
  \subsection{What are "service contracts"?}\label{sec:internal:contracts}
\emph{Service contracts}, as implemented by the acs-service-contract package of the OpenACS core, introduces \emph{call abstraction}, a concept with as many dimensions as actual areas of usage, to OpenACS as framework. The idea is not to reproduce existing documentation on service contracts, but to generalise the problem tackled by contracts. Service contracts aim at providing some sort of re-usability and a generic extension mechanism at the framework level. Call abstraction is a generic concept that can be found at the level of programming languages (of various flavours, OO and non-OO, functional etc.) and as infrastructure facilities in frameworks of various kind. The general motivation for call abstraction is a twofold: First, we want to assemble complex code blocks (i.e. a proc, involving sequences of calls to other code blocks) at design time (i.e. the time we conceptualise and write our program). Second, however, we do not want to specify a concrete addressee of some calls in our code block at run time. Call abstraction might be referred to as \emph{identity transparency} which simply means the actual addressees or callees are not determined at design time! The simple motivation for these two requirements is that we want to allow varying behaviour within a more generally designed picture. Varying behaviour should be able to be introduced in a pre-defined and standardised manner. Let's take an example, taken from the OO-verse of XOTcl which gives a nice show case example, easier graspable than a general description of service contracts as such. 
%
\lstset{breaklines=true,numbers=left,basicstyle=\footnotesize,frame=single}
\lstinputlisting[firstnumber=1,firstline=4,lastline=13]{../examples/xorb/example-01-call-abstraction.xotcl}
%
Imagine, you set out to provide an full-text search in your application. In OpenACS, you might think of the "search" package as a direct example. An important role in this infrastructure module is played by an indexer that either on-demand or at regular intervals triggers the indexation of new text items. The indexer is represented by an XOTcl object  "Indexer" that offers a method "index" responsible for the actual indexing walk-through. The fundamental design problem now is how to provide for the possibility to add new kinds of indexable items at an arbitrary point in time after the design and implementation of the indexer as such. To make it short, how to provide extensibility to the indexer? Key to an appropriate solution is the definition of a generic interface which needs to implemented by all indexable items that might be added in the future. 
%
\lstinputlisting[firstnumber=last,firstline=15,lastline=16]{../examples/xorb/example-01-call-abstraction.xotcl}
%
This "caller interface", represented by the XOTcl class "Indexable" shown above, stipulates an abstract call "getContent" that needs to be resolved to a concrete call at runtime. Resolving means, in an OO setting, that implementing sub-classes of Indexable come with a non-abstract method "getContent". At \begin{math}t_0\end{math}, i.e. design and implementation time of the infrastructure module, the per-object method "index" therefore exclusively refers to an abstract call "getContent". This is also known as template method, a prominent design pattern documented by \cite{gof:1994}.
%
\lstinputlisting[firstnumber=last,firstline=18,lastline=26]{../examples/xorb/example-01-call-abstraction.xotcl}
%
As can be seen from the above snippet, by implementing "Indexable" and providing a concrete method "getContent" forum entries will be indexed upon future runs of the indexer, i.e. calls to "index". Registration, in our example, is realised by establishing a sub class relationship to Indexable. If, at \begin{math}t_1\end{math}, wiki pages should be also be included in the full-text index, another specialised sub class of Indexable is needed:
%
\lstinputlisting[firstnumber=last,firstline=37,lastline=44]{../examples/xorb/example-01-call-abstraction.xotcl}
%
This is a simple sketch of what extensibility is in this reading. Note,  call abstractions in various settings come with different connotations (i.e. semantics), but they share basic ideas. Coming back to "service contracts" that realise call abstractions at a non-OO framework level, you might think of "service contracts" as abstract classes such as Indexable in the above example and of "service implementations" as registrars, represented by creating a sub class of Indexable. A more generic picture of call abstraction is given by Figure \ref{fig:advanced:ca:1}: 
  \begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.55\textwidth]{img/call-abstraction-scheme.png}
\caption{Call abstraction}
\label{fig:advanced:ca:1}
\end{center}
\end{figure}
The XOTcl example (and OpenACS service contracts) would translate into the following roles shown by the schematic outline: The class Indexable (a service contract such as FtsContentProvider) stipulates takes the role of \emph{interface (descriptions)}. In this role, they have two responsibilites, first interfacing to the caller (caller interface) and interfacing to the callee (callee interface). The caller is an arbitrary code block that issues the index call on objects of type Indexable. The callee, or servant, is the concrete getContent method of any sub class derived from class Indexable (e.g. XowikiPage, or, the service implementation content\_revision). The proxy role is taken by the getContent method defined on Indexable and declared abstract (in OACS service contracts, these are operations defined on contracts).

A final clarification is needed at this point: What has become known as "remote procedure calls" (RPC) or "remote method invocations" (RMI) is the basic idea of call abstraction, but identity transparency is accompanied by \emph{location transparency}.

  % call abstractions
  % interface descriptions
 % \section{Feature sets}
  %\subsection{xorb}
  %\subsection{xosoap}
  %\section{Roadmap}
   %\subsection{xorb}	
  %\subsection{xosoap}
  \section{Appendix} 
  \subsection{Examples - xosoap}
 \lstinputlisting[breaklines=true,numbers=none,label=lst:quickstart:xosoap:2,frame=single,basicstyle=
\footnotesize,caption=A simple SOAP client]{../examples/xosoap/example-01-soap-consumer.tcl}
  \lstinputlisting[breaklines=true,numbers=none,label=lst:quickstart:xosoap:3,frame=single,basicstyle=
\footnotesize,caption=An even simpler SOAP client]{../examples/xosoap/example-02-soap-consumer.tcl}
    \lstinputlisting[breaklines=true,numbers=none,label=lst:quickstart:xosoap:4,frame=single,basicstyle=\footnotesize,caption=An XOTcl Object as SOAP client]{../examples/xosoap/example-03-soap-consumer.tcl}
        \lstinputlisting[breaklines=true,numbers=none,label=lst:quickstart:xosoap:5,basicstyle=\footnotesize,caption=Using proxy templates/ template methods (I)]{../examples/xosoap/example-04-soap-consumer.tcl}
     \lstinputlisting[breaklines=true,numbers=none,label=lst:quickstart:xosoap:6,basicstyle=\footnotesize,caption=Using proxy templates/ template methods (II)]{../examples/xosoap/example-05-soap-consumer.tcl}
     \lstinputlisting[breaklines=true,numbers=none,basicstyle=
\footnotesize,label=lst:quickstart:xosoap:7,caption=A simple SOAP service]{../examples/xosoap/example-07-soap-provider-init.tcl}
\lstinputlisting[breaklines=true,numbers=none,basicstyle=\footnotesize,caption=Per-method precedence,label=lst:quickstart:xosoap:8]{../examples/xosoap/example-08-soap-consumer.tcl}
\lstinputlisting[breaklines=true,numbers=none,basicstyle=\footnotesize,caption=Shared scope,label=lst:quickstart:xosoap:9]{../examples/xosoap/example-09-soap-consumer.tcl}
\lstinputlisting[breaklines=true,caption=A more advanced service implementation,numbers=none,basicstyle=\footnotesize,label=lst:quickstart:xosoap:10]{../examples/xosoap/example-10-soap-provider-init.tcl}

 \newpage
 \bibliography{/Users/ssoberni/Documents/doc/diss/thesis}
 \newpage
\printindex
    \end{document}
    
    %        In the following section, I assume that you have OpenACS 5.1+ or DotLRN 
%        2.1.3+ up and running on your localhost at the default port 
%        80.\footnote{The version requirements result from the actual 
%        requirements for the underlying \href{http://www.xotcl.org}{XOTcl} 
%        extensions to OpenACS, see e.g. 
%        \href{http://media.wu-wien.ac.at/download/README-xotcl-core}{XOTcl 
%        installation readme for OpenACS}.} When referring to code artefacts, I
%        will skip namespaces used (e.g. xosoap::*) for the sake of readability.
%        As xoSoap aims at providing remoting 
%        for \href{http://www.xotcl.org}{XOTcl} objects deployed within the 
%        OpenACS/ DotLRN framework, in a first step, you have to make sure that 
%        XOTcl extensions to OpenACS are properly installed for your OpenACS/ 
%        DotLRN instance: \subsubsection{Introducing OO to OACS} Upgrading your 
%        OACS instance to the powerful OO features of 
%        \href{http://www.xotcl.org}{XOTcl} is fairly straight forward and 
%        involves three steps: First, you have to add the 
%        \href{http://www.xotcl.org}{XOTcl} Tcl-extension library as module to 
%        your AOLServer installation. Then, you are required to patch your 
%        OpenACS core, mainly to allow XOTcl's auxiliary facilities to be loaded 
%        at the very beginning of the bootstrap loading process (see 
%        \href{http://openacs.org/forums/message-view?message_id=313344}{TIP 
%        #87} for details on merging XOTcl extensions with the OACS core). 
%        Complete and thorough upgrading instruction come with the XOTcl 
%        extension distribution, you find them at 
%        \href{http://media.wu-wien.ac.at/download/README-xotcl-core}{http://media.wu-wien.ac.at/
download/README-xotcl-core}. 
%        Note: These instructions do not only cover the set up process for XOTcl 
%        fundamentals but also for some jelly beans, e.g. a threaded profiling 
%        environment etc.\footnote{The family of XOTcl-based OACS extensions 
%        grows rapidly: Included in the XOTcl distribution, there is an advanced 
%        repository management component (XOTcl-Note), Gustaf Neumann recently 
%        came up with a Wiki extension for OACS called
% 	        \href{http://openacs.org/forums/message-view?message_id=334982}{xoWiki}.} 
%        xoSoap only requires the basic bundle of XOTcl artefacts, i.e. the 
%        AOLServer module, the auxiliary XOTcl core package and the two patches 
%        to the OACS core. All of these can be retrieved directly from 
%        \href{http://media.wu-wien.ac.at/download/}{http://media.wu-wien.ac.at/download/}. 
%        At the time of writing this document, these were the following files or 
%        files" versions:
%          \begin{itemize}
%            \item
%            \href{http://media.wu-wien.ac.at/download/xotcl-1.3.8.tar.gz}{xotcl-1.3.8.tar.gz}
%            \item
%            \href{http://media.wu-wien.ac.at/download/xotcl-core-0.19.apm}{xotcl-core-0.19.apm}
%            \item
%            \href{http://media.wu-wien.ac.at/download/acs-api-documentation-procs.patch}{acs-api-
documentation-procs.patch}
%            \item
%            \href{http://media.wu-wien.ac.at/download/acs-bootstrap-installer.patch}{acs-bootstrap-
installer.patch}
%          \end{itemize}
%            Get these and follow the relevant instruction in 
%            \href{http://media.wu-wien.ac.at/download/README-xotcl-core}{README-xotcl-core}.
% 	      \subsubsection{Setting up xoSoap}
%            xoSoap comes in an APM flavour and can therefore be easily 
%            incorporated into your OpenACS installation:
%       \begin{enumerate}
%         \item Grab the current xoSoap distribution package from
%         \href{http://stefan.thinkersfoot.net}{http://stefan.thinkersfoot.net}
%         and load the xoSoap package (either assisted by APM package manager or 
%         manually) e.g.:
%        \lstset{basicstyle=\small}
% 		\begin{lstlisting}[language=bash,breaklines=true,label=lst:loadpkg]         
%         cd <path-to-your-oacs-instance>/packages 
%         # (e.g. /var/lib/aolserver/<instance/packages) 
%         wget http://stefan.thinkersfoot.net/file_download/4          
%         \end{lstlisting} 
%         Alternatively, you can directly "load" the package by using the APM 
%         package manager that allows for retrieving a package from your local 
%         filesystem or a remote web repository. To do so, go to 
%         /acs-admin/apm/package-load and follow the instructions.
%         \item Install xoSoap: Depending on whether you use or stick with the 
%         APM package manger, either go to /acs-admin/apm/packages-install or 
%         simply /acs-admin/install. xoSoap will then be mounted under /xosoap.
%         \begin{enumerate}
%           \item In the former case, select the check box representing the 
%           loaded xoSoap package and continue with "Next". Installation should 
%           be completed right away as there is no database / data model 
%           modification/ extension necessary.
%           \item In the latter case, select "Install from local" and then the 
%           "Service" branch of locally loaded packages available for 
%           installation. xoSoap should then be properly listed.
%         \end{enumerate}
%           \item Restart the AOLServer.
%           \item Verify that xoSoap is correctly initialised.
%	         \begin{enumerate}
%                   \item First, check /logs/error.log for some basic 
%                   notifications issued by xoSoap upon initialization: xoSoap 
%                   informs you about hooking itself into the request processor 
%                   chain, therefore look for a notification that says "[xoSoap] 
%                   preauth filter set for post requests debarking at /xosoap*."
%                   Besides, make sure that all library files (*-procs.tcl) were
%                   loaded appropriately by taking a sample of messages posted by the
%                   bootstrap loader. Watch out for notifications saying
%                   "Loading" or "Loaded packages/xosoap/<procs-file>" and possible
%                   sourcing errors.
%                   \item Go to /xosoap. There, you are supposed to find some 
%                   basic information about services (XOTcl objects) hosted and 
%                   registered for remoting (see Figure \ref{fig:hideout}). 
%                   Note: You will find information about a sample service that 
%                   comes with the xoSoap distribution named SqiTarget. Please, 
%                   refer to Section \ref{sec:publish} for more details.
%	         \end{enumerate}
%       \end{enumerate}
%                   \begin{figure}[htb] \centering
%\includegraphics{img/hideout}
%\caption{xoSoap's hideout}
%\label{fig:hideout}
%\end{figure}
    
%So far you have got xoSoap up and running. At this point you will be briefed on
%how to create and publish your own web service. Some basics:
%\begin{itemize}
%\item Usually SOAP frameworks distinguish between creating or declaring a
%service and deploying it. Under its roof, xoSoap does the very same. However, the 
%deployment step does not require any efforts by you, in fact, it is not even 
%visible at first sight. This is due to the fact that the deployment logic
%is encapsulated by the actual service syntax that you have to deal with
%(see Section \ref{sec:design}).
%\item Currently, the service declaring code is supposed to be placed into
%*-init.tcl files in your package. As xoSoap is loaded in the first bootstrap run
%that sources all *-procs.tcl files, it is not guaranteed that you can make use
%of xoSoap facilities in your procs-files. However, you are not limited to store
%your services in the native xoSoap package /tcl directory. Feel free to extend
%your (existing) packages by xoSoap services.
%\item Take a closer look at your xoSoap's library directory (i.e.
%<...>/packages/xosoap/tcl): There, you will find an examples-init.tcl
%file that comes with a small sample service, called Poem. I will closely follow
%this service example when outlining the process of service creation below.
%\end{itemize}
%Let's break it down into smaller bits and pieces:
%\begin{enumerate}
%  \item Create a custom namespace hosting your service declarations (Note:
%  xoSoap does not impose any restrictions on the usage of namespaces):
%    \lstset{basicstyle=\small}
% 		\begin{lstlisting}[language=tcl,breaklines=true,label=lst:declarens]         
%         namespace eval services {
%         # service declaration
%         }         
%         \end{lstlisting}   
%\item Then, you have to create the actual service from the Service 
%meta-class. Note that creating a xoSoap service does not differ from writing 
%XOTcl code as such. So if you are familiar with basic concepts of XOTcl 
%(meta-classes, object properties / parameters etc.) skip the next few steps. 
%Defining a service is done by declaring a XOTcl class. The service skeleton, a 
%XOTcl meta-class, provides for (1) the registration of the service with the 
%Invoker in several steps, (2) the definition of a lifecycle model for your 
%service (i.e. either static / persistent or per-request) and (3) the enclosure 
%or "hoarding" of service methods. The following line creates a new service
%called "Poem": 
%\lstset{basicstyle=\small}
% 		\begin{lstlisting}[language=tcl,breaklines=true,label=lst:declarservice]         
%         ::xosoap::Service Poem     
%         \end{lstlisting}   
%\item For the moment, the Poem service is completely disrobed, it does not come
%with any service-specific method defined upon it. Therefore, the service does
%not expose any functionality to the outer space. By adding any number of methods
%or instprocs to the newly created class, you can provide for these. The
%following lines attach functionality to the class" instances, the actual service
%objects. In the Poem example included in the distribution (see
%examples-init.tcl) the method actual implements a simple echo service, i.e. it
%returns a steadily growing vers. In other words, the object accumulates
%statements collected from the requesting clients ("statement" argument) and
%returns the current state to the request-issueing clients.
%\lstset{basicstyle=\small}
% 		\begin{lstlisting}[language=tcl,breaklines=true,label=lst:declarservice]         
%         Poem instproc getPoem {statement} {         
%         	# method's body         
%         }   
%         \end{lstlisting}  
%\item The two line blocks above give you a rudimentary but fully functioning
%service that can be called from a remote or local SOAP client. However, there
%are many refinements to consider:
%\begin{itemize}
%  \item Lifecycling: This refers to the design decision on the time-to-live for
%  service objects. Are they supposed to be creately only once, upon AOLServer /
%  OACS intialisation, stay alive and are reused for handling requests by several
%  requestors, or do you want each request / connection thread to be served by a
%  new or rejuvenated object. Both styles, referred to as "static instance" and
%  "per-request instance", allow for realising different application scenarios
%  (see Section \ref{sec:design} for a more thorough discussion). xoSoap leaves
%  the decision to you, by setting the optional lifecycle parameter of 
%  ::xosoao::Service either to 0 (per-request flavour; default) or 1 (static
%  instance). The Poem service declaration above gives you
%  short-living\footnote{Note: "Short living" is not the correct wording as it
%  turns
%  out to be relative to the time frame it takes for a servant object to process
%  an invocation task. In fact, "short-living servants" should be rephrased
%  "lemming servants" as their meeting-the-end is imposed forcefully.} service
%  objects (also referred to as servants), the following modification stretches
%  its time-to-live. If not the clear for the moment, testing will the Poem echo
%  service will give you illumination (see \ref{}): 
%  \lstset{basicstyle=\small}
% 		\begin{lstlisting}[language=tcl,breaklines=true,label=lst:declarservice1]         
%         ::xosoap::Service Poem -lifecycle 1  
%         \end{lstlisting}     
%\item Activation: Activation per se does not only refer to initialising an
%servant's inner state in a pre-defined manner, but might involve various tasks.
%At this point we stick with its limited scope, i.e. initialisation of an
%object's state. By defining a custom constructor method (the \textit{init}
%instproc), you can controll the (1) initial creation process upon the first
%request and (2) --- in case of per-request instances --- their regeneration:
%\lstset{basicstyle=\small}
% 		\begin{lstlisting}[language=tcl,breaklines=true,label=lst:declarinit]         
%    Poem instproc init {} {	
%		my set result "Rose"	
%}
%         \end{lstlisting} 
%The block above creates a constructor that is called at the time of a
%servant's creation (instantiation of the service class) and sets the initial
%vers of the poem to be constructed. Statements by the requesting clients will
%then be appended to this initial state.
%\item Hoarding: By default, any method you define on the service class will be
%exposed for remote invocation. In order to give you more control about the dis-
%or, actually, the enclosure of functionality exposed, Service
%meta-class provides you with the parameter "hoard". By passing a list of method
%names to this parameter you can define an interface "ad negativum" and prevent
%methods, such as the constructor, to be invokable remotely. So after this
%refinement we end up with the following service class declaration:
%\lstset{basicstyle=\small}
% 		\begin{lstlisting}[language=tcl,breaklines=true,label=lst:declarservice2]         
%    ::xosoap::Service Poem -hoard [list init] -lifecycle 1
%         \end{lstlisting} 
%\end{itemize}
%\item Save your coding artefact and restart the AOLServer.
%\item Testing: xoSoap was developed with and tested against two SOAP frameworks
%that can be used with (XO)Tcl: \href{http://tclsoap.sourceforge.net/}{tclsoap}
%(version 1.6.7) and \href{http://www.cs.fsu.edu/~engelen/soap.html}{gSoap}, a
%SOAP suite for C/C++ that can easily be extended by Tcl bindings. For the
%moment, I provide a few-liner sample tclsoap consumer in this distribution and for
%the included Poem echo service (see <...>/xosoap/tcl/doc/poem.tcl). I therefore
%assume that you know how to set up tclsoap properly:
%\lstset{basicstyle=\small}
% 		\begin{lstlisting}[language=tcl,breaklines=true,label=lst:declarservice2]         
%package req SOAP

%SOAP::create getPoem \
%        -uri "urn:xmethods-getPoem" \
%        -proxy "http://localhost/xosoap/services/SqiTarget" \
%        -params { "statement" "string"}

%puts [getPoem "is a rose"]

%         \end{lstlisting} 
%\item Enjoy watching the creation of the widely known part of Gertrude Stein's
%Sacred Emily poem written in 1912.
%  \end{enumerate}
%  \subsection{Mangling messages using Interceptors}\label{sec:usinginterceptors}
%Now you can easily deploy your own web services or recast existing OpenACS 
%functionality written in XOTcl in a service-style manner. xoSoap gives you the
%opportunity to extend its functionality according to your needs, i.e. the
%invocation procedure, by means of invocation interceptors, also known as
%"handlers" in other web service frameworks. Although this feature is still
%maturing, you can plugin in basic logging, monitoring, debugging or
%security-relevant features (authentication) by writting your own interceptors.
%For the moment, xoSoap
%distinguishes between interceptors that listen at the request flow (incoming
%messages, RequestInterceptors) and those listening at the response flow
%(outgoing messages, ResponseInterceptors):
%  \section{xoSoap sandboxes}
%  \subsection{Implementing the Simple Query Interface (SQI)}
%  \section{Dissecting xoSoap}
%  \subsection{Design overview}\label{sec:design}
%  \subsection{Little design gems}
%  \subsubsection{Intercepting message flows}
%  In Section \ref{sec:usinginterceptors} I introduced to you the usage of
%  interceptors / handlers to listen at the flows of request and response in
%  order to plug-in additional pre- and post-invocation functionality. The
%  following section wants to give some insights on the actual design of
%  interception in xoSoap. While reading, you might refer to the code
%  documentation as well, providing more details on each of the code artefacts
%  involved in the realisation of interception. The top-level concept is the
%  interception \textit{scope}, i.e. the scope for application of an interceptor
%  with respect to threads. Certain scenarios (e.g. caching) require
%  state-preserving interception while others can equally be realized at the
%  level of each connection (thread). Therefore, xoSoap currently comes with two
%  interception scopes, a connection scope and an invoker scope. This is
%  realised by attaching a chain of interceptors to core objects in either
%  thread sphere (see Figure \ref{fig:icpt-design}). Interceptor {chains} make
%  use of one of XOTcls interception techniques, mixins, i.e. per-object mixins to
%  more precise.\footnote{Please refer to the mixin-section of the \href{http://media.wu-wien.ac.at/doc/
tutorial.html#mixins}{XOTcl
%  manual} for more details in per-object and per-class mixins.} The XOTcl class
%  InterceptorChain serves as superclass of both the MessageHandler and the
%  Invoker class. Upon instantiation of MessageHandler (in the main / blueprint
%  and therefore each connection thread) or Invoker (in the invoker thread), the
%  constructor of InvocationChain is called and nests two \textit{flow} objects,
%  Request- and ResponseFlow, into the two objects just created. As XOTcl
%  mixins allow for propagation of specific method calls\footnote{This happens
%  by extending and therefore along the so called \textit{next}-path, see
%  \href{http://media.wu-wien.ac.at/doc/tutorial.html#mixins}{XOTcl
%  manual}.}, calls upon the handleRequest / handleResponse methods provided by
%  both MessageHandler and Invoker are redirected, first to the shadowed methods
%  of InvocationChain, i.e. their common superclass. 
%  
%   \begin{figure}[htb] \centering
%\includegraphics{img/interceptor-design}
%\caption{Intercepting architecture -- Scopes, Chain, Flows, Bouncers}
%\label{fig:icpt-design}
%\end{figure}
%  
%  The latter then administers the call to the respective nested
%  flow objects that actually have mixed-in the inceptor mixin classes (the
%  registration procedure is outlined later in this section). This redirection
%  along a method chaining (\textit{next}-) path is at the core of
%  interception as realised in xoSoap. Intercepting requests and responses might
%  come in two flavours, either intercepting-forwarding or
%  intercepting-bouncing. The latter is required by default in order to return
%  the result of a chain of interceptors, i.e. the mangled request / response,
%  back to the intially calling object / method, i.e. MessageHandler or Invoker.
%  Therefore interceptors can be written as flow \textit{bouncers}, they may
%  break a chain of interceptors by returning the status quo to the caller (see
%  Section \ref{sec:usinginterceptors}. xoSoap comes with two built-in flow
%  bouncers that are responsible for delimiter the list of mixins attached to a
%  flow object. In other words, they are in charge of closing request and
%  response flows and bounce the mangled request / response back to the calling
%  object (look for FlowBouncerForMessageChain and
%  FlowBouncerForInvokerChain in the source documentation). However,
%  this final bouncing involves different operations in either scope:
%  FlowBouncerForMessageChain (connection scope) forwards the request to
%  the invoker thread while FlowBouncerForInvokerChain initiates the
%  actual invocation procedure (see Figure \ref{fig:icpt-design}).
%  
%  \paragraph{Precedence order of interceptors}
%  In which precise order are interceptors enforced, i.e. can they intercept
%  requests / responses and mangle them? From your perspective as coder
%  of concrete interceptors it follows the principle of
%  "first-come-first-serve". To put it differently, what is declared first is
%  registered earlier in the respective chain and called first. Focusing xoSoap
%  internals, the precedence order derives from the order of the mixin list,
%  i.e. the list of mixin classes registered with a specific object. This list
%  of mixins can be altered in terms of a simple Tcl list\footnote{Refer to the
%  \href{http://media.wu-wien.ac.at/doc/tutorial.html#updateinterceptors}{XOTcl
%  manual}.} Each interceptor customly defined is simply appended to this list,
%  the two built-in bouncing interceptors, however, are made sticky at the very
%  end of the mixin list in order to make sure that chain does not become broken
%  at the very, very end. Custom bouncers are subject to the same precedence
%  strategy. Precedence is materialised by the underlying registration procedure.
%  
%  \paragraph{Registration procedure for interceptors} 
%  
%  The class InvocationChain includes a method register that handles the
%  hooking-in of newly declared interceptors, i.e. mixin classes. Registration
%  is realised in several steps, distributed among three artefacts:
%  \begin{enumerate}
%        \item The meta-class Interceptor provides for the selection of
%        the targeted scope in which the new interceptor is to be placed. The
%        constructor of Interceptor first collects the value of the
%        \textit{-scope} parameter (0 by default) and applies a switch: In case
%        of 0, the interceptor is passed to the addInterceptor method exposed by
%        the concrete object derived from MessageHandler. The object
%        inherits the registration method (addInterceptor) from
%        InvocationChain. In case of 1, i.e. the invoker thread is
%        targeted and the interceptor will apply to all incoming requests and
%        responses, the switch expression enforces a delayed registration.
%        Postponing the registration to the end of the intialization process is
%        necessary due to the current design of OACS's init process\footnote{See
%        \href{http://openacs.org/forums/message-view?message_id=324185}{OACS
%        forum} for a detailled discussion.}. This is achieved by queueing the
%        actual registration call on Invoker's addInterceptor method
%        with \lstinline[[language=tcl]!ad_after_server_initialization!.
%        \item The actual registration is performed by addInterceptor method
%        hosted by InterceptorChain. It is in charge of two tasks: (1)
%        As interceptors might either listen at the flow of requests or responses
%        or both, the have to be mixed-in accordingly, i.e. appended to the list
%        of mixin classes of either RequestFlow or ResponseFlow. Interceptors are
%        required to derive from either of the following or both "abstract"
%        superclasses: RequestInterceptor or / and
%        ResponseInterceptor. These prescribe the implementation of two
%        abstract methods, handleRequest or handleResponse. Upon registration,
%        addInterceptor performs a type check and registers each
%        Interceptor according to its superclass relationsships. (2)
%        Each flow has to be terminated by a flow bouncer. After successfully
%        registering a new Interceptor, addInterceptor provides for
%        re-appending of the built-in bouncer and re-initiating the mixin list. 
%      \end{enumerate}
%      
%       \begin{figure}[htb] \centering
%\includegraphics{img/interceptor-design-register}
%\caption{Intercepting architecture -- Registration & Precedence}
%\label{fig:icpt-design-register}
%\end{figure}
%  	 
%  \section{Benchmarking / Profiling}
%  \section{Known Issues}
%  \section{To-dos} 
